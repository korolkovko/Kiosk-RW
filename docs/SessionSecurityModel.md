# Session & Security Model

Этот документ описывает, как система самообслуживания (киоск + админка + сайт + мобильное приложение) обрабатывает сессии, безопасность, пароли, ключи, сертификаты и авторизацию. Все термины поясняются, чтобы не было двусмысленностей. Также приведены сценарные примеры использования и поведения при сбоях.

# Модель Сессий и Безопасности

FSM реализован отдельно, но тесно связан с моделью сессий.
Для сайта потребуется свой FSMWebSite, для мобильного приложения FSMMobAPP соответственно

---

## 1. Термины и сущности

- SessionID
  -  Уникальный UUID каждой клиентской сессии
  - **Генерируется на сервере**
    - Сервер вызывает UUID генератор (например, `uuid4()` в Python)
    - Это происходит внутри контроллера или middleware при запросе `/session/start`
  - **Ни один клиент не должен генерировать SessionID самостоятельно**
    - Исключение может быть сделано только при оффлайн-режиме, но это требует отдельной архитектуры
  - Возникает:
    - При первом взаимодействии с сервером (касание экрана, открытие сайта, запуск приложения)
  - Клиент получает SessionID в ответе и сохраняет его в localStorage, SecureStore и т.п.
  - Используется как идентификатор в последующих запросах
  - Может использоваться в заголовке `X-Session-ID` или как часть тела запроса (если нужно)

- JWT (JSON Web Token)
  - Подписанный токен от сервера, формат: Base64(Header).Base64(Payload).Signature
  - Подпись выполняется с использованием алгоритма:
    - HS256 (секретный ключ) — для простых систем
    - RS256 (парная подпись с приватным ключом и публичной валидацией) — для более защищённых
  - **Генерируется сервером**
    - При авторизации пользователя (`/auth/login`)
    - При старте доверенного устройства (`/device/auth`)
  - **Отправляется клиенту один раз в ответе**
    - Хранится на клиенте (SecureStore, localStorage и т.д.)
    - Передаётся в каждом запросе в заголовке:
      ```
      Authorization: Bearer <JWT>
      ```
  - **Не хранится на сервере**
    - Сервер валидирует подпись и `exp` при каждом запросе
  - Может быть двух типов:
    - DeviceToken — для доверенных устройств (KIOSK)
    - UserToken — для авторизованных пользователей (WEB, MOBILE)
  - Содержит следующие поля:
    - `iat` — issued at (время выпуска)
    - `exp` — expiration time (время истечения)
    - `user_id`, `device_id`, `role`, `scope` — в зависимости от типа

- TTL (Time To Live)
  - Определяет время жизни временных сущностей:
    - Сессии (`SessionID`)
    - JWT
    - FSM-записи
  - **Управляется на разных уровнях**:
    - SessionState — через Redis TTL
    - JWT — через `exp` внутри токена (unix timestamp)
    - FSM — в базе, через поля `started_at`, `last_active`, `timeout`
  - Конкретные значения TTL:
    - SessionState: 15 минут неактивности
    - DeviceToken: 30 дней (обновляется заранее)
    - UserToken: 24 часа (может обновляться через refresh)
    - FSM: 5–15 минут (зависит от состояния)
    - WebSocket: 60 сек без соединения → FSM прерывается

- WebSocket
  - Долгоживущий двусторонний канал между клиентом и сервером (`wss://...`)
  - **Открывается клиентом KIOSK после получения SessionID и DeviceToken**
  - Управляется через backend WebSocket-сервер (например, `FastAPI + WebSocket`, `Socket.io`, `Django Channels`)
  - Используется для:
    - Всего процесса заказа и обновления остатков, резервов, для получени информации о стопах или изменении цены елси это просиходит в процессе заказа
    - Стартов и переходов FSM
    - Получения статусов оплаты, печати, фискализации
    - Показов ошибок, отмен, подтверждений
  - **Не используется на WEB и MOBILE**, чтобы:
    - Упростить архитектуру
    - Не зависеть от открытости вкладки или активности приложения
    - Избежать ненужной нагрузки и подвешенных соединений
  - Поведение при обрыве:
    - Если соединение разорвано > 60 сек → FSM завершает заказ с ошибкой
    - Интерфейс сбрасывается или предлагает повтор
---

## 2. Различие между известным и неизвестным пользователем

- Анонимный пользователь
  - Не проходит авторизацию
  - Получает только SessionID
  - Не имеет JWT (UserToken отсутствует)
  - Может:
    - Просматривать меню
    - Формировать корзину
    - оформлять заказ

- Авторизованный пользователь
  - Проходит авторизацию и получает JWT (UserToken)
  - Имеет SessionID + JWT
  - Идентифицируется через `user_id`, зашитый в JWT
  - Может:
    - Делать всё то же, что и анонимный
    - Получать доступ к персональным данным (например, история заказов)
    - Использовать повторные заказы, акции, скидки и т.п.

- Важное замечание:
  - **С точки зрения backend-системы — все пользователи обрабатываются одинаково**
  - Единственное различие — **наличие `user_id` в SessionState и JWT**
  - FSM, логика заказов и взаимодействия не зависят от того, известен пользователь или нет
  - Поэтому все операции (оплата, FSM, печать) работают как для авторизованных, так и для анонимных клиентов

---

## 3. Типы клиентов и сессий

### KIOSK (терминал самообслуживания)

- Анонимный клиент:
  - Заголовки:
    - Authorization: Bearer <DeviceToken>
    - X-Client-Source: KIOSK
  - SessionID: да (генерируется сервером)
  - JWT: один токен:
    - DeviceToken — используется для идентификации терминала, доверенного устройства
  - WebSocket: да (обязателен)
  - FSM: FSMKiosk (обязателен)
  - Особенности:
    - Клиент — физическое лицо, взаимодействующее с устройством
    - WebSocket запускается сразу после старта сессии
    - FSM отслеживает: оплату (POS), чек (KKT/принтер), завершение (кухня)

- Авторизованный клиент (если киоск поддерживает авторизацию — например, по телефону или QR-коду):
  - Заголовки:
    - Authorization: Bearer <UserToken>
    - X-Device-Token: <DeviceToken>  (можно использовать отдельный заголовок)
    - X-Client-Source: KIOSK
  - SessionID: да
  - JWT: два отдельных токена:
    - DeviceToken — идентифицирует само устройство
    - UserToken — идентифицирует пользователя
  - WebSocket: да
  - FSM: FSMKiosk
  - Особенности:
    - Возможность сохранять историю заказов пользователя
    - Возможность применять персональные скидки, баллы и т.п.

---

### WEB (браузер на сайте)

- Анонимный пользователь:
  - Заголовки:
    - X-Client-Source: WEB
  - SessionID: да
  - JWT: нет
  - WebSocket: нет
  - FSM: FSMWebSite (опционален, если пользователь оформляет заказ)
  - Особенности:
    - Используется для предзаказов без оплаты
    - FSM может управлять заказом, но не требует оборудования
    - Интерфейс может использовать polling или REST-запросы

- Авторизованный пользователь:
  - Заголовки:
    - Authorization: Bearer <UserToken>
    - X-Client-Source: WEB
  - SessionID: да
  - JWT: один токен:
    - UserToken — идентифицирует пользователя
  - WebSocket: нет
  - FSM: FSMWebSite (если заказ оформлен)
  - Особенности:
    - Доступ к истории заказов
    - Возможность привязки к loyalty-системе
    - Поведение FSM может учитывать статус пользователя

---

### MOBILE (мобильное приложение)

- Анонимный пользователь:
  - Заголовки:
    - X-Client-Source: MOBILE
    - X-Device-ID: <уникальный ID устройства>
  - SessionID: да
  - JWT: нет
  - WebSocket: нет
  - FSM: FSMMobApp (если оформляется заказ)
  - Особенности:
    - FSM может запускаться при подтверждении заказа
    - Интерфейс может использовать push-уведомления для отслеживания
    - Ограничения по оплате и фискализации зависят от реализации

- Авторизованный пользователь:
  - Заголовки:
    - Authorization: Bearer <UserToken>
    - X-Client-Source: MOBILE
    - X-Device-ID: <уникальный ID устройства>
  - SessionID: да
  - JWT: один токен:
    - UserToken — идентифицирует пользователя
  - WebSocket: нет
  - FSM: FSMMobApp (если заказ оформлен)
  - Особенности:
    - Доступ к истории заказов и персональным данным
    - Возможность интеграции с платёжными платформами (ApplePay, GooglePay)
    - FSM может включать шаги подтверждения и оплаты


---
## 4. Инициация сессии (по типам клиентов)

### Общая логика

- Любой клиент (анонимный или авторизованный) вызывает `POST /session/start`
- Сервер:
  - генерирует `SessionID` (UUID4),
  - сохраняет его в Redis или in-memory store с TTL (15 мин),
  - возвращает SessionID в теле ответа (или куки, если используется),
  - при необходимости возвращает `JWT` (если аутентификация присутствует),
  - открывает WebSocket (только для KIOSK),
  - логирует сессию и client_type.

---

### KIOSK (терминал)

#### Анонимный клиент

- Запрос:
  - `POST /session/start`
- Заголовки:
  - `Authorization: Bearer <DeviceToken>`
  - `X-Client-Source: KIOSK`
- Сервер:
  - генерирует SessionID
  - валидирует DeviceToken
  - сохраняет SessionState: session_id + device_id + client_type=KIOSK
- Клиент:
  - сохраняет SessionID
  - открывает WebSocket
- FSM:
  - будет запущен при нажатии «Оплатить»

#### Авторизованный клиент

- Запрос:
  - `POST /session/start` или `/auth/login`
- Заголовки:
  - `Authorization: Bearer <UserToken>`
  - `X-Device-Token: <DeviceToken>`
  - `X-Client-Source: KIOSK`
- Сервер:
  - валидирует оба токена (User + Device)
  - создаёт SessionState: session_id + user_id + device_id + client_type=KIOSK
- Клиент:
  - сохраняет SessionID и оба токена
  - открывает WebSocket
- FSM:
  - запускается при оплате
  - может учитывать user_id (например, лояльность)

---

### WEB (браузер)

#### Анонимный пользователь

- Запрос:
  - `POST /session/start`
- Заголовки:
  - `X-Client-Source: WEB`
- Сервер:
  - генерирует SessionID
  - SessionState: session_id + client_type=WEB
- Клиент:
  - сохраняет SessionID
- FSM:
  - запускается только если пользователь оформляет заказ
  - FSMWebSite не требует POS, KKT, WebSocket

#### Авторизованный пользователь

- Запрос:
  - `POST /auth/login`
- Заголовки:
  - `Authorization: Bearer <UserToken>`
  - `X-Client-Source: WEB`
- Сервер:
  - валидирует UserToken
  - SessionState: session_id + user_id + client_type=WEB
- Клиент:
  - сохраняет SessionID и JWT
- FSM:
  - FSMWebSite, может привязываться к user_id

---

### MOBILE (приложение)

#### Анонимный пользователь

- Запрос:
  - `POST /session/start`
- Заголовки:
  - `X-Client-Source: MOBILE`
  - `X-Device-ID: <some-unique-device-id>`
- Сервер:
  - генерирует SessionID
  - SessionState: session_id + device_id (если передан) + client_type=MOBILE
- Клиент:
  - сохраняет SessionID
- FSM:
  - FSMMobileApp — запускается при оформлении заказа

#### Авторизованный пользователь

- Запрос:
  - `POST /auth/login` → получение JWT
  - `POST /session/start` → инициация сессии с авторизацией
- Заголовки:
  - `Authorization: Bearer <UserToken>`
  - `X-Client-Source: MOBILE`
  - `X-Device-ID: <some-unique-device-id>`
- Сервер:
  - валидирует JWT
  - SessionState: session_id + user_id + device_id + client_type=MOBILE
- Клиент:
  - сохраняет SessionID и JWT
- FSM:
  - FSMMobileApp
  - может использовать push-уведомления вместо WebSocket



---

## 5. Структура SessionState

- session_id: UUID  
  Уникальный идентификатор сессии. Генерируется сервером при старте.

- client_type: "KIOSK" | "WEB" | "MOBILE"  
  Источник сессии. Используется для маршрутизации логики.

- user_id: int | null  
  Устанавливается, если пользователь авторизован (по UserToken). Иначе null.

- device_id: int | null  
  Устанавливается, если запрос пришёл от доверенного устройства (по DeviceToken). Иначе null.

- created_at: timestamp  
  Время создания сессии. Записывается один раз.

- last_active_at: timestamp  
  Обновляется при каждом взаимодействии с API. Используется для TTL и автоочистки.

- expires_at: timestamp  
  Время истечения сессии. Устанавливается по политике TTL (обычно 15 мин от last_active_at).

- websocket_state: "open" | "closed"  
  Используется только для KIOSK. Помогает следить за живым соединением с клиентом.

---

## 6. JWT

- Типы:
  - DeviceToken
    - Пример:
      ```
      {
        "device_id": "KIOSK-001",
        "device_type": "KIOSK",
        "scope": ["POS", "KKT"],
        "iat": 1721122334,
        "exp": 1723714334
      }
      ```

  - UserToken
    - Пример:
      ```
      {
        "user_id": 12345,
        "role": "CUSTOMER",
        "phone": "+79001234567",
        "iat": 1721122334,
        "exp": 1721208734
      }
      ```

---

## 7. TTL (время жизни объектов)

- SessionID
  - На клиенте: живёт, пока не очищен localStorage
  - На сервере: TTL — 15 минут неактивности
  - **Рекомендуется явно очищать SessionID на клиенте**:
    - После завершения заказа
    - При возврате на главный экран
    - При ошибке FSM или разрыве соединения
    - При выходе пользователя (если он авторизован)

- DeviceToken
  - TTL: 30 дней
  - Обновляется через `/device/refresh`

- UserToken
  - TTL: 24 часа
  - Возможность обновления через refresh_token (позже)

- FSM
  - TTL: 5–15 минут (в зависимости от статуса)
  - Авто-завершение при неактивности

- WebSocket
  - Разрыв соединения более 60 сек → FSM завершает заказ ошибкой - !!!СРАВНИТЬ С ТАЙМЕРАМИ FSM!!!

---

## 8. Где что хранится

- SessionID
  - На клиенте (localStorage, SecureStore)
  - На сервере (Redis)

- JWT
  - Только на клиенте
  - Сервер валидирует по подписи

- FSM
  - Хранится в БД
  - Связан с session_id и order_id

---

## 8. Почему WebSocket только для киоска (пока по крайней мере)

- Только киоск требует real-time отклика от внешних систем:
  - POS (оплата)
  - KKT (фискализация)
  - Printer (чек)
  - Kitchen (готовность заказа)

- Пользователь стоит перед экраном — нужна немедленная реакция:
  - Статусы, ошибки, подтверждения

- Веб или приложение:
  - Пользователь может закрыть экран, уйти
  - Подходит REST/polling или push-уведомления

- WebSocket для других клиентов можно внедрить при необходимости
  - Например, чтобы отслеживать прогресс заказа

---

## 10. Повторное использование компонентов

- SessionState
  - Общая структура и принцип хранения едины для всех клиентов (SessionID, user_id, device_id, TTL)
  - Реализация логики и хранения — единая (например, Redis)

- JWT
  - Общий формат (подписанный токен с iat, exp)
  - Разные payload:
    - DeviceToken для устройств
    - UserToken для пользователей

- FSM
  - Общий подход: управление жизненным циклом заказа (init → завершение)
  - **Но FSM реализуется отдельно для каждого типа клиента:**
    - FSMKiosk — с POS, KKT, принтером, WebSocket, реальным временем
    - FSMWebSite — без оборудования, может использовать email/SMS подтверждения
    - FSMMobApp — с онлайн-оплатой, пуш-уведомлениями, асинхронными статусами
  - FSM API может быть схожим (например, `/fsm/start`, `/fsm/status`), но поведение и тайминги — разные

- Логирование заказов
  - Все FSM реализуют единый принцип логирования:
    - События → `OrderLifecycleLog`
    - Статусы → `OrderFSMRuntime`
  - Это обеспечивает унификацию хранения и мониторинга, несмотря на разницу в логике
---

## 11. Примеры сценариев

### Заказ с киоска

- Пользователь касается экрана
- POST `/session/start`
- Сервер возвращает SessionID + WebSocket открыт
- Выбор блюд, оплата через POS
- FSM запускается
- KKT → чек → Printer → FSM
- Kitchen → завершение
- FSM → `COMPLETED`

### Анонимный пользователь на сайте

- Открытие сайта → POST `/session/start`
- Выбор блюд, оформление предзаказа
- FSM не запускается (если нет оплаты)
- Session TTL 15 минут

### Авторизованный пользователь в приложении

- Ввод телефона → получение JWT
- Создание SessionID
- Оформление заказа
- Возможна онлайн-оплата
- FFSMMobApp создаётся и управляется через REST (без WebSocket)

---

## 11. В итоге

- Все клиенты (KIOSK, WEB, MOBILE) используют:
  - Единую систему сессий (SessionID + SessionState)
  - Общую модель авторизации (JWT, если применимо)
  - Общую структуру безопасности (TLS, подписанные токены, Redis TTL)

- FSM реализуется отдельно для каждого типа клиента:
  - FSMKiosk — управляет POS, KKT, печатью и требует WebSocket
  - FSMWebSite — упрощённый поток без оборудования
  - FSMMobApp — ориентирован на онлайн-оплату и пуш-уведомления
  - Общий принцип завершения FSM в терминальное состояние сохраняется во всех случаях

- WebSocket используется только для KIOSK
  - Он обязателен для real-time взаимодействия с оборудованием

- JWT — опционален
  - Используется только если клиент авторизован (UserToken) или является доверенным устройством (DeviceToken)
  - Отсутствие токена не мешает функционированию анонимных сценариев

- SessionID — обязателен всегда
  - Присутствует у всех клиентов, даже без авторизации
  - Используется как основной идентификатор сессии и связующий элемент в FSM и заказах

- Архитектура:
  - Чётко отделяет клиентов, пользователей и устройства
  - Масштабируема: можно добавлять новые FSM и клиентские интерфейсы
  - Безопасна: всё взаимодействие идёт по HTTPS, данные не дублируются на сервере

## 12. Хранение и защита данных

### SessionID

- Хранится:
  - На клиенте (в localStorage, SecureStore, AsyncStorage и т.п.)
  - На сервере — в Redis или in-memory store (по ключу `session:{uuid}`)
- TTL:
  - 15 минут неактивности
- Удаляется:
  - Сервер — по TTL
  - Клиент — вручную при завершении заказа или выхода

---

### JWT (UserToken и DeviceToken)

- Хранится:
  - Только на клиенте (localStorage, SecureStore, keychain и т.п.)
  - Сервер **не хранит токены**
- Валидация:
  - На сервере по подписи (HS256 или RS256)
  - Проверка `exp`, `iat`, `scope`, `role`, `user_id` и т.п.
- Обновление:
  - DeviceToken: через `/device/refresh` (например, за 5 дней до истечения)
  - UserToken: через механизм `refresh_token` (если реализован)
- Удаление:
  - Клиент сам удаляет при logout, сбросе или ошибке 401
- Безопасность:
  - Передаются только через HTTPS
  - Запрещено хранить в `window`-переменных и cookie без `HttpOnly`

---

### WebSocket

- Данные, передаваемые через WebSocket:
  - Только события FSM и идентификаторы (`session_id`, `order_id`)
  - Никогда не передаётся JWT, пароль или конфиденциальные данные
- Защищён:
  - Используется только `wss://` (TLS)

---

### Пароли (для пользователей и администраторов)

- Хранение:
  - Только в виде хэша (bcrypt)
  - Хэш включает соль, уникальную для каждого пользователя
- Не храним:
  - Оригинальные пароли
  - Пароли в токенах
- Верификация:
  - Проверка пароля происходит через сравнение bcrypt-хэшей
- Обновление:
  - Через `/auth/change-password` или админку
  - Старый хэш полностью заменяется

---

### TLS-сертификаты

- Используются:
  - Для HTTPS (`https://api.domain.com`)
  - Для WebSocket (`wss://...`)
- Хранение:
  - На сервере (например, `/etc/ssl/`, `/etc/letsencrypt/`)
- Обновление:
  - Автоматически (если Let's Encrypt используется)
  - Или вручную (если используется внешний сертификат)
- Валидация:
  - Все клиенты должны принимать только доверенные корневые сертификаты
  - При недоверенных сертификатах — соединение не устанавливается

---

### Ключи устройств (POS, KKT, Принтеры)

- Не храним в системе
  - Все криптографические ключи встроены в SDK устройств (например, KKT-фискальник)
  - Используются локально на устройстве через защищённый API
- Аутентификация устройства происходит по:
  - Серийному номеру (например, `KKT-123456`)
  - Протоколам TLS на уровне SDK
- Если устройство скомпрометировано — блокируется через внешний интерфейс (админка, POS-сервер)

---

### База данных

- Доступ:
  - Только из изолированной сети
  - С использованием SSL (если доступ извне)
- Защита:
  - Пароли и токены в БД не хранятся в открытом виде
  - Логи очищаются от чувствительных данных
- Бэкапы:

  - Хранятся в зашифрованном виде (желательно)

---

### Логи

  - Все чувствительные данные (пароли, токены, номера карт) фильтруются при логировании
  - Используются маски: `****` или `null`
