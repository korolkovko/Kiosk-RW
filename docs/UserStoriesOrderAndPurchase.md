ВВЕДЕНИЕ К USER STORIES БЛОКА ЗАКАЗОВ И FSM

О ЧЁМ ЭТОТ БЛОК

Данный блок описывает последовательность действий пользователя и системы в процессе создания и выполнения заказа через киоск самообслуживания.  
Он включает весь жизненный цикл заказа: от просмотра меню до оплаты, печати, передачи на кухню и финальной выдачи.

Каждая история сфокусирована на отдельном шаге или ветке конечного автомата (FSM), который управляет логикой исполнения заказа.  
Описания охватывают как нормальный сценарий, так и ситуации с ошибками, таймаутами, отменой и взаимодействием с внешними системами.

---

КАК ВСЁ УСТРОЕНО

- Пользователь **анонимен**, авторизация не требуется.
- Все действия происходят в рамках одного **сеанса** на киоске (`Device.DeviceType = 'KIOSK'`).
- До момента оплаты данные заказа хранятся **во временной корзине** (на фронте или в Redis).
- При нажатии кнопки «Оплатить» система:
  - создаёт запись `Order` в базе данных PostgreSQL,
  - запускает FSM через `OrderFSMRuntime`,
  - управляет всеми шагами (оплата, фискализация, печать, передача).
- Все ключевые шаги логируются в `OrderLifecycleLog`, что обеспечивает возможность мониторинга, восстановления и отладки.

FSM — это **единая точка правды**, управляющая поведением заказа после нажатия «Оплатить».

---

ЧТО ТАКОЕ МЕНЮ — И ЧТО МЫ С НИМ ДЕЛАЕМ

Меню — это **представление**. То, как мы его отображаем на киоске, не связано напрямую с архитектурой базы данных.  
С точки зрения backend, **всё — это `ItemLive`**, а то, как эти `ItemLive` группируются, оформляются и применяются, определяется на уровне бизнес-логики и фронта.

Любой `ItemLive` может выступать:**
- как обычная позиция меню (бургер, напиток),
- как **модификатор** (например, "добавить сыр" — это отдельный `ItemLive` с ценой),
- как часть **комбо-набора** (где каждый элемент — отдельный `ItemLive` с общим родительским `ComboID`),
- как скрытый элемент (например, техническая надбавка, обёртка, спец-позиция для тестирования),
- как **сезонная позиция**, которая активна только в определённые даты.

Таким образом, **всё в системе — это просто набор `ItemLive` с нужными атрибутами**.

Backend возвращает меню:
- отфильтрованное по `IsActive = true`,
- с учётом категории (например, "Напитки", "Закуски"),
- с учётом сезонности (`AvailableFrom` / `AvailableUntil`),
- сгруппированное в логической и визуальной форме, подходящей для киоска.

Фронт может отображать эти данные как простое меню, как модификаторы, как выбор опций — всё зависит от конфигурации и категорий.

---

ОБЩИЙ ПРОХОД FSM И ОБРАБОТКА КРИТИЧЕСКИХ СИТУАЦИЙ

Процесс работы FSM начинается, когда пользователь нажимает «Оплатить».  
До этого всё работает без участия базы данных, только через Redis или фронт.

Основной проход:

1. Пользователь собирает корзину (временное хранилище).
2. Нажимает «Оплатить» → создаётся `Order`, запускается FSM.
3. Выполняется оплата через POS (`Device.Type = 'POS'`).
4. При успехе → фискализация через ККТ (`Device.Type = 'KKT'`).
5. При успехе → генерация `PickupCode` и `PinCode`.
6. Печать чека и кода → отображение пользователю.
7. Передача заказа на кухню (webhook/API/очередь).
8. Получение подтверждения от кухни → FSM завершает заказ.

Критические ситуации, которые уже предусмотрены:

- Неудачная оплата (decline, связь, карта) → FSM завершает заказ с ошибкой.
- Неудачная фискализация → FSM переходит в ветку аварийной обработки.
- Неудачная печать → коды отображаются на экране, FSM завершает заказ корректно.
- Таймаут бездействия (пользователь ушёл) → заказ автоматически отменяется.
- Пользователь нажал «назад» из экрана оплаты → FSM временно приостанавливается.
- Явная отмена заказа до оплаты → заказ логируется как отменённый.
- Успешная выдача заказа фиксируется внешней системой → FSM завершает заказ.

Каждая ситуация сопровождается записью в `OrderLifecycleLog`, что позволяет отслеживать поведение и реализовать мониторинг.

---

ЗАЧЕМ ЭТОТ НАБОР USER STORIES

Этот набор `User Stories`:

- описывает все реальные сценарии взаимодействия пользователя с киоском,
- основан на точных названиях сущностей и полей из модели данных `Full_Domain_Model`,
- покрывает основные и некоторые (НЕ ВСЕ - НАДО ЕЩЕ ПРИДУМАТЬ) пограничные сценарии FSM,


USER STORY (US001)
    ПРОСМОТР МЕНЮ И ВЫБОР ПОЗИЦИИ ПОЛЬЗОВАТЕЛЕМ

    USER STORY (US001) DESCRIPTION:
        Как анонимный покупатель,
        я хочу увидеть список доступных позиций из меню,
        чтобы выбрать товар и перейти к добавлению в корзину.

    НАЧАЛЬНОЕ СОСТОЯНИЕ:

        Пользователь не авторизован.

        Интерфейс открыт на экране киоска (Device.DeviceType = 'KIOSK').

        Меню сформировано заранее и содержит активные позиции из ItemLive, где IsActive = true.

        Остатки доступны из ItemLiveAvailable, StockLiveQuantity > 0.

    ВЫХОДНОЕ СОСТОЯНИЕ:

        Пользователь видит список:

        ItemLive.NameRu/NameEng, ItemLive.DescriptionRu/Eng, ItemPriceGross, UnitOfMeasureRu/Eng

        Только те, у которых StockLiveQuantity > 0 и IsActive = true

        Пользователь нажимает на позицию → переходит к экрану добавления в корзину

    ИСПОЛЬЗУЕМЫЕ СУЩНОСТИ:

        ItemLive (основная информация о позиции)

        ItemLiveAvailable (остатки, возможность заказа)

USER STORY (US002)
    ДОБАВЛЕНИЕ ПОЗИЦИИ В КОРЗИНУ

    USER STORY (US002) DESCRIPTION:
        Как анонимный покупатель,
        я хочу выбрать товар из меню и указать количество,
        чтобы добавить его во временную корзину перед оплатой.

    НАЧАЛЬНОЕ СОСТОЯНИЕ:

        Пользователь не авторизован.

        На экране отображается список позиций из ItemLive.

        Пользователь выбрал одну из позиций (ItemID известен).

        Корзина ещё не существует или пуста.

    ВЫХОДНОЕ СОСТОЯНИЕ:

        Если корзины не существует — она создаётся в оперативной памяти (на фронте) или в Redis.

        В структуре корзины добавляется новая запись с ItemID, Quantity, ItemPriceGross и прочими необходимыми параметрами.

        Обновление данных в Redis или фронтовом состоянии выполняется синхронно.

        Таблица Order в базе данных PostgreSQL **не создаётся** на этом этапе.

        Таблица OrderItem также не используется — все данные о выбранных позициях хранятся во временном состоянии (в памяти фронта или в Redis).

        Таблица ItemLiveAvailable также не изменяется — резерв товара не происходит до момента начала оплаты.

    ТЕХНИЧЕСКОЕ ПРИМЕЧАНИЕ:

        Order создаётся в базе данных PostgreSQL только тогда, когда пользователь нажал “оплатить” и запускается работа конечного автомата (Finite State Machine, FSM).
        
        До этого момента корзина хранится временно — в оперативной памяти фронтенда (например, в переменной состояния) или в Redis с ключом по SessionID.

    ИСПОЛЬЗУЕМЫЕ СУЩНОСТИ:

        ItemLive (основная информация о позиции)

        Корзина (во временном хранилище — фронт)        
        
USER STORY (US003)
    ИЗМЕНЕНИЕ КОЛИЧЕСТВА ИЛИ УДАЛЕНИЕ ПОЗИЦИИ ИЗ КОРЗИНЫ

    USER STORY (US003) DESCRIPTION:
        Как анонимный покупатель,
        я хочу изменить количество выбранного товара или удалить его из корзины,
        чтобы скорректировать свой выбор до начала оплаты.

    НАЧАЛЬНОЕ СОСТОЯНИЕ:

        Пользователь не авторизован.

        Во временной корзине (на фронте или в Redis) уже добавлены одна или несколько позиций.

        Корзина идентифицируется по уникальному SessionID, связанному с устройством пользователя.

        Таблица Order в базе данных PostgreSQL ещё не создана.

    ВЫХОДНОЕ СОСТОЯНИЕ:

        Если количество позиции изменено:
            - соответствующая запись в корзине (в Redis или на фронте) обновляется.
            - при этом резерв доступного товара в ItemLiveAvailable ещё не изменяется.

        Если количество позиции установлено в 0:
            - позиция удаляется из корзины.

        Все изменения происходят во временном хранилище корзины.

        В базе данных PostgreSQL ничего не сохраняется — таблицы Order и OrderItem остаются пустыми.

        Таблица ItemLiveAvailable не обновляется — резерв не применяется до начала оплаты.

    ТЕХНИЧЕСКОЕ ПРИМЕЧАНИЕ:

        Order создаётся в базе данных PostgreSQL только тогда, когда пользователь нажал “оплатить” и запускается работа конечного автомата (Finite State Machine, FSM).
        
        До этого момента корзина хранится временно — в оперативной памяти фронтенда (например, в переменной состояния) или в Redis с ключом по SessionID.

    ИСПОЛЬЗУЕМЫЕ СУЩНОСТИ:

        ItemLive (основная информация о позиции)

        Корзина (во временном хранилище — фронт)
    
USER STORY (US004)
    НАЖАТИЕ КНОПКИ «ОПЛАТИТЬ» И ИНИЦИАЦИЯ ТРАНЗАКЦИИ (FSM)

    USER STORY (US004) DESCRIPTION:
        Как анонимный покупатель,
        я хочу подтвердить текущую корзину и нажать «Оплатить»,
        чтобы начать процесс оплаты с фискализацией, печатью и получением пин-кода.

    НАЧАЛЬНОЕ СОСТОЯНИЕ:

        Пользователь не авторизован.

        Корзина сформирована во фронте (в оперативной памяти), содержит одну или несколько позиций с Quantity > 0

        Указано корректное количество (Quantity > 0) по всем позициям.

        Для всех позиций в корзине достаточно остатков: ItemLiveAvailable.StockLiveQuantity ≥ Quantity.

        Ни Order, ни OrderItem, ни OrderFSMRuntime ещё не существуют в базе данных PostgreSQL.

    ВЫХОДНОЕ СОСТОЯНИЕ:

        Создаётся запись в таблице Order со статусом PENDING.

        По каждой позиции из корзины создаются записи в OrderItem, с сохранением snapshot-данных:

        NameRu/Eng, Description, UnitOfMeasure, ItemPriceNet, ItemVatRate, ItemVatAmount, ItemPriceGross и др.

        В таблице ItemLiveAvailable:

        уменьшается StockLiveQuantity,

        увеличивается ReservedQuantity.

        Создаётся OrderFSMRuntime:

        FSMState = INIT

        OrderID и DeviceID сохраняются

        стартует FSM: происходит переход INIT → AWAITING_PAYMENT по событию FSM_STARTED.

        Логируется начальное событие в OrderLifecycleLog (TriggerEvent = FSM_STARTED).

        Если ранее были неудачные попытки оплаты — создаются записи в Payment с Status = DECLINED, ERROR, и т.д.

        Пользователь перенаправляется на экран ожидания оплаты (интерфейс киоска переходит в состояние ожидания ответа от POS-терминала).

    ТЕХНИЧЕСКОЕ ПРИМЕЧАНИЕ:

        Order создаётся в базе данных PostgreSQL только тогда, когда пользователь нажал “оплатить” и запускается работа конечного автомата (Finite State Machine, FSM).
        
        До этого момента корзина хранится временно — в оперативной памяти фронтенда.

        Этот шаг считается точкой входа в FSM: с этого момента заказ считается активным и требует завершения, отмены или фиксации ошибки.

    ИСПОЛЬЗУЕМЫЕ СУЩНОСТИ:

        Order

        OrderItem

        ItemLiveAvailable

        OrderFSMRuntime

        OrderLifecycleLog

        Payment
        
USER STORY (US005)
    УСПЕШНАЯ ОПЛАТА С ПОМОЩЬЮ POS-ТЕРМИНАЛА

    USER STORY (US005) DESCRIPTION:
        Как анонимный покупатель,
        я хочу оплатить заказ через POS-терминал с банковской картой,
        чтобы завершить платёж и продолжить выполнение заказа (фискализация, выдача).

    НАЧАЛЬНОЕ СОСТОЯНИЕ:

        Пользователь не авторизован.

        Существует активный заказ в таблице Order со статусом PENDING.

        Запущен FSM-процесс:

        есть запись в OrderFSMRuntime со FSMState = AWAITING_PAYMENT.

        POS-терминал подключён и зарегистрирован как Device, DeviceType = 'POS_TERMINAL'InitialDomainModel.

        Система ожидает платёж от пользователя.

        Фискализация и печать ещё не производились.

        Заказ отображается на экране терминала, ожидается платёж.

        Подключён POS-терминал, зарегистрированный как Device с DeviceType = 'POS'.


    ВЫХОДНОЕ СОСТОЯНИЕ:

        В Payment создаётся новая запись с атрибутами:

            OrderID

            Method → ссылка на PaymentMethod с Code = 'Card' (или аналог)

            TotalAmountGross (итоговая сумма)

            Status = 'PAID'

            PosTerminalID (устройство)

            TransactionId, ResponseCode, ResponseMessage, CompletedAt и др.

        В OrderFSMRuntime:

        FSM переходит в состояние AWAITING_FISCALIZATION по событию PAYMENT_SUCCEEDEDFSMStatesAndTransitions.

        В OrderLifecycleLog логируется событие:

        TriggerEvent = PAYMENT_SUCCEEDED

        FromState = AWAITING_PAYMENT

        ToState = AWAITING_FISCALIZATION

        ActorType = PosTerminal, ActorID = DeviceID POS-терминала.

        Пользователь видит экран “Ожидание чека” (новое состояние FSM).

    ТЕХНИЧЕСКОЕ ПРИМЕЧАНИЕ:

        Оплата выполняется через интеграцию с POS-терминалом (эквайринг), при этом система делает не более двух попыток подключения к одному или нескольким устройствам типа POS.

        В случае успешного ответа от терминала данные о транзакции сохраняются в таблице Payment.

        POS-терминал является внешним устройством, триггерящим переход в FSM.

        Система допускает одну повторную попытку оплаты, если первая завершилась с технической ошибкой (PAYMENT_RETRY) — после чего FSM либо продолжает, либо завершает с UNSUCCESSFUL_PAYMENTFSMStatesAndTransitions.

        Информация о попытках фиксируется в Payment, FSM реагирует только на успешный результат (Status = 'PAID').
        
    ИСПОЛЬЗУЕМЫЕ СУЩНОСТИ:

        Order

        OrderFSMRuntime

        OrderLifecycleLog

        Payment

        Device (POS-терминал)
        
USER STORY (US006)
    НЕУДАЧНАЯ ОПЛАТА С ПОМОЩЬЮ POS-ТЕРМИНАЛА

    USER STORY (US006) DESCRIPTION:
        Как анонимный покупатель,
        я хочу получить понятное сообщение в случае неудачной оплаты через POS-терминал,
        чтобы понять, в чём проблема, и при необходимости повторить попытку.

    НАЧАЛЬНОЕ СОСТОЯНИЕ:

        Пользователь не авторизован.

        Существует заказ в таблице Order со статусом PENDING.

        FSM запущен: существует OrderFSMRuntime в активном состоянии запись в OrderFSMRuntime, FSMState = AWAITING_PAYMENT.

        Пользователь находится на экране “Ожидание оплаты”.

        POS-терминал зарегистрирован в таблице Device, DeviceType = 'POS_TERMINAL'.

        FSM инициировал первую попытку оплаты через POS.

    ВЫХОДНОЕ СОСТОЯНИЕ:

        Вариант 1: Первая попытка неудачна, но ошибка допускает повтор
            В Payment создаётся запись:

            OrderID

            Status = 'DECLINED' или Status = 'ERROR'

            ResponseCode, ResponseMessage, PosTerminalID, TransactionId и др.

            В OrderLifecycleLog записано событие PAYMENT_FAILED.

            FSM остаётся в состоянии AWAITING_PAYMENT, но выполняет self-loop PAYMENT_RETRYFSMStatesAndTransitions.

            Показывается сообщение:

            Если ошибка банковская — уведомление для покупателя (например, "Недостаточно средств").

            Если ошибка системная — сообщение о технической проблеме (например, "Ошибка терминала").

            FSM пробует вторую попытку оплаты (возможно, с другим устройством POS).

        Вариант 2: Вторая попытка тоже неудачна
            Создаётся вторая запись в Payment со статусом DECLINED или ERROR.

            В OrderLifecycleLog добавляется событие PAYMENT_FAILED.

            FSM переходит в терминальное состояние UNSUCCESSFUL_PAYMENTFSMStatesAndTransitions.

            В OrderFSMRuntime фиксируется ошибка оплаты.

            Пользователь видит экран об ошибке оплаты.

            Система может:

            вывести QR-код для обратной связи (предусмотрено архитектурно),

            уведомить администратора (в рамках будущей логики мониторинга).

    ТЕХНИЧЕСКОЕ ПРИМЕЧАНИЕ:

        SM допускает две попытки оплаты:

            первая → self-loop PAYMENT_RETRY (если ошибка считается recoverable),

            вторая → финальное завершение в случае неудачи.

        Все попытки фиксируются в Payment, с точным временем, кодами ошибок, устройством POS.

        FSM различает типы ошибок:

            бизнес-ошибки (decline, insufficient funds) → показываются покупателю,

            технические ошибки (timeout, no response) → требуют логирования и, возможно, эскалации.

    ИСПОЛЬЗУЕМЫЕ СУЩНОСТИ:

        Order

        OrderFSMRuntime

        OrderLifecycleLog

        Payment

        Device (POS-терминал)
        
USER STORY (US007)
    УСПЕШНАЯ ФИСКАЛИЗАЦИЯ ЧЕКА

    USER STORY (US007) DESCRIPTION:
        Как покупатель,
        я хочу, чтобы после успешной оплаты мой заказ был фискализирован через кассу (ККТ),
        чтобы получить фискальный чек в соответствии с законодательством.

    НАЧАЛЬНОЕ СОСТОЯНИЕ:

        Пользователь не авторизован.

        Заказ успешно оплачен:

            Order.OrderStatus = PENDING (ещё не завершён, но FSM прошёл этап оплаты).

            В Payment есть запись со Status = 'PAID'.

        FSM находится в состоянии AWAITING_FISCALIZATION (OrderFSMRuntime.FSMState).

        Устройство Device типа FISCAL_PRINTER или KKT определено системой и готово к работе.

        В OrderFSMRuntime.FiscalDeviceID указан ID активного ККТ-устройства.

        Система определила доступное устройство Device с типом 'KKT' (фискальный регистратор).

    ВЫХОДНОЕ СОСТОЯНИЕ:

        FSM инициализирует вызов фискализации:
            - Обращается к ККТ (напрямую или через прокси/сервис).
            - Список позиций, ставки НДС, суммы (OrderItem, Order.TotalAmount...).

        При получении положительного ответа от ККТ:

            Создаётся запись в FiscalReceipt (❗ не SummaryReceipt — он создаётся позже):

                OrderID, ReceiptFiscalMachineReturnedID, ReceiptBody, CreatedAt.

            FSM переходит в состояние AWAITING_PRINTING по событию FISCALIZATION_SUCCEEDEDFSMStatesAndTransitions.

            В OrderLifecycleLog логируется переход:

                FromState = AWAITING_FISCALIZATION

                ToState = AWAITING_PRINTING

                TriggerEvent = FISCALIZATION_SUCCEEDED

                ActorType = FiscalDevice, ActorID = DeviceID.

            В OrderFSMRuntime обновляется состояние FSM и фиксируется результат фискализации.

        Пользователь переводится на экран “Ожидание печати чека”.

    ТЕХНИЧЕСКОЕ ПРИМЕЧАНИЕ:

        SM допускает одну повторную попытку фискализации (FISCALIZATION_RETRY) с таймаутом (например, 10–20 секунд)FSMStatesAndTransitions.

        Ошибки на этом этапе (например, сбой ККТ) обрабатываются отдельно — см. USER STORY US008.

        Устройство FiscalDevice выбирается из Device, DeviceType = 'FISCAL_PRINTER' или DeviceType = 'KKT'.

        Данные от ККТ (включая FiscalDocumentNumber, FiscalSign, OFD ID) сохраняются в FiscalReceipt.
    
    ИСПОЛЬЗУЕМЫЕ СУЩНОСТИ:

        Order

        OrderFSMRuntime

        OrderLifecycleLog

        FiscalReceipt

        Device (DeviceType = 'FISCAL_PRINTER' или KKT)
        
USER STORY (US008)
    НЕУДАЧНАЯ ФИСКАЛИЗАЦИЯ ЧЕКА

    USER STORY (US008) DESCRIPTION:
        Как покупатель,
        я хочу быть проинформирован в случае ошибки при фискализации чека,
        чтобы понимать, что происходит, и получить инструкцию или помощь от системы.

    НАЧАЛЬНОЕ СОСТОЯНИЕ:

        Пользователь не авторизован.

        Заказ (Order) оплачен успешно — FSM находится в состоянии AWAITING_FISCALIZATION

        Активна FSM-сессия: OrderFSMRuntime в состоянии ожидания фискализации.

        Имеется подтверждённый платёж (Payment.Status = 'success').

        FSM инициирует вызов на ККТ (устройство Device с типом 'KKT').

    ВЫХОДНОЕ СОСТОЯНИЕ:

        ККТ возвращает ошибку (например, нет связи, отказ, сбой фискального модуля).

        FSM фиксирует событие FISCALIZATION_FAILED и остаётся в AWAITING_FISCALIZATION (если допустим retry) или завершает с ошибкой.

        В OrderLifecycleLog создаётся запись:

            FromState = AWAITING_FISCALIZATION

            ToState = UNSUCCESSFUL_FISCALIZATION

            TriggerEvent = FISCALIZATION_FAILED

            ActorType = FiscalDevice, ActorID = DeviceID

            Comment = код ошибки, описание.

        Если это первая ошибка, FSM может перейти по self-loop FISCALIZATION_RETRY (одноразово)FSMStatesAndTransitions.

        Если вторая попытка также завершилась неудачей:

            FSM переходит в терминальное состояние UNSUCCESSFUL_FISCALIZATION.

            В OrderFSMRuntime обновляется финальное состояние и результат попытки.

            Пользователю показывается экран с технической ошибкой.

            Может быть выведен QR-код с данными заказа для обращения к персоналу.

            Система может логгировать инцидент и направить уведомление администратору.



    ТЕХНИЧЕСКОЕ ПРИМЕЧАНИЕ:

        FSM различает типы ошибок:

            Временные — допустим FISCALIZATION_RETRY (например, нет ответа, нестабильная связь).

            Критические — UNSUCCESSFUL_FISCALIZATION сразу (например, ошибка ФН, фатальная ошибка ККТ).

        Поведение должно логироваться:

            В OrderFSMRuntime — время начала и завершения попытки (FiscalAttemptStartedAt, FiscalAttemptResponseAt, FiscalAttemptResultCode, FiscalAttemptResultDescription).

        Заказ остаётся в системе, но требует ручной обработки (через админ-интерфейс или Recovery Pipeline)

    ИСПОЛЬЗУЕМЫЕ СУЩНОСТИ:

        Order

        OrderFSMRuntime

        OrderLifecycleLog

        Device (DeviceType = 'FISCAL_PRINTER' или KKT)

        FiscalReceipt — не создаётся при неуспехе

        SummaryReceipt — также отсутствует
        
USER STORY (US009)
    ПЕЧАТЬ ЧЕКА И ВЫДАЧА PIN/PICKUP-КОДА

    USER STORY (US009) DESCRIPTION:
        Как покупатель,
        я хочу получить напечатанный чек и уникальный код получения (pickup/pin),
        чтобы подтвердить свою покупку и иметь возможность забрать заказ.

    НАЧАЛЬНОЕ СОСТОЯНИЕ:

        Пользователь не авторизован (Session.UserID = null).

        Заказ успешно оплачен и фискализирован (Payment.Status = 'PAID', есть FiscalReceipt).

        FSM находится в состоянии AWAITING_PRINTING (OrderFSMRuntime.FSMState)FSMStatesAndTransitions.

        Сформирован SummaryReceipt, который объединяет FiscalReceipt, SlipReceipt, PickupCode, PinCodeInitialDomainModel.

        Устройство печати определено: Device.DeviceType = 'FISCAL_PRINTER' или 'KKT+PRINTER'.

        OrderFSMRuntime.PrintingDeviceID указан и готов к печати.

    ВЫХОДНОЕ СОСТОЯНИЕ:

        FSM инициирует печать итогового документа:
            - Формируется содержимое для печати:
                - реквизиты заказа (номер, дата, сумма)
                - фискальные данные из SummaryReceipt
                - PickupCode и PinCode — сгенерированы и получены из FSM (OrderFSMRuntime)

            - PickupCode и PinCode сохраняются:
                - в OrderFSMRuntime как рабочие коды доступа
                - в SummaryReceipt как часть финального документа для печати

            - Документ печатается через устройство Device.

            При успехе:

                FSM фиксирует событие PRINT_SUCCEEDED.

                Переходит в состояние AWAITING_EXECUTION_CONFIRMATIONFSMStatesAndTransitions.

                В OrderLifecycleLog создаётся запись:

                    FromState = AWAITING_PRINTING

                    ToState = AWAITING_EXECUTION_CONFIRMATION

                    TriggerEvent = PRINT_SUCCEEDED

                    ActorType = Printer, ActorID = DeviceID.

                Пользователь видит финальный экран:

                    Информация об успешной оплате.

                    Визуальное отображение Pickup/Pin-кодов (включая QR-код, если реализовано).

    ТЕХНИЧЕСКОЕ ПРИМЕЧАНИЕ:

        КPickupCode и PinCode являются частью FSM и служат идентификаторами получения.

        Если печать невозможна (см. US010), FSM предложит альтернативу: отображение кода на экране (с подтверждением от пользователя).

        Возможность повторной печати можно предусмотреть отдельно (по запросу или автоматически при восстановлении устройства).

        Все события логируются для восстановления или аудита.

    ИСПОЛЬЗУЕМЫЕ СУЩНОСТИ:

       OrderFSMRuntime — содержит PickupCode, PinCode, PrintingDeviceID, состояния попыток печати

        SummaryReceipt — объединяет все данные чека и дублирует коды

        OrderLifecycleLog — логирует переход PRINT_SUCCEEDED

        Device (DeviceType = 'FISCAL_PRINTER' или KKT+PRINTER) — печатное устройство
        
USER STORY (US010)
    НЕУДАЧНАЯ ПЕЧАТЬ И АЛЬТЕРНАТИВНАЯ ВЫДАЧА КОДА

    USER STORY (US010) DESCRIPTION:
        Как покупатель,
        я хочу получить информацию о завершённом заказе даже в случае неудачной печати,
        чтобы иметь возможность забрать заказ с помощью отображённого на экране PIN/Pickup-кода.

    НАЧАЛЬНОЕ СОСТОЯНИЕ:

        Заказ успешно оплачен и фискализирован (Payment.Status = 'PAID', FiscalReceipt создан).

        FSM находится в состоянии AWAITING_PRINTING (OrderFSMRuntime.FSMState).

        PickupCode и PinCode уже сгенерированы и сохранены:

            в OrderFSMRuntime

            в SummaryReceipt

        Устройство печати (Device.DeviceType = 'FISCAL_PRINTER' или 'KKT+PRINTER') недоступно, не отвечает или возникла иная ошибка печати.

    ВЫХОДНОЕ СОСТОЯНИЕ:

        FSM фиксирует сбой печати:

            В OrderLifecycleLog создаётся запись:

                FromState = AWAITING_PRINTING

                ToState = PRINT_FAILED

                TriggerEvent = PRINTING_FAILED_OR_TIMEOUT

                ActorType = Printer, ActorID = DeviceID

                Comment = описание ошибки/таймаута

            FSM переходит в состояние PRINT_FAILEDFSMStatesAndTransitions.

        Пользователю отображается экран с PickupCode и PinCode:

            данные получены из OrderFSMRuntime и/или SummaryReceipt

            коды могут быть представлены в виде QR-кода

        У пользователя есть выбор:

            нажать кнопку “Получить код без чека” (или аналогичную)

            это инициирует событие PRINTING_FAILED_ALTERNATIVE_RECEIPT_ACCEPTED_BY_USER
            → FSM переходит в AWAITING_EXECUTION_CONFIRMATION

        В OrderLifecycleLog создаётся соответствующая запись:

            TriggerEvent = PRINTING_FAILED_ALTERNATIVE_RECEIPT_ACCEPTED_BY_USER

            FromState = PRINT_FAILED

            ToState = AWAITING_EXECUTION_CONFIRMATION

            ActorType = Customer

        Если пользователь не подтверждает или не реагирует 20 секунд:

            FSM переходит в финальное состояние UNSUCCESSFUL_PRINTING_ALTERNATIVE_RECEIPT_DECLINED

    ТЕХНИЧЕСКОЕ ПРИМЕЧАНИЕ:

        SM чётко различает:

            ошибку печати (бумага, offline, ошибка устройства) — допустима альтернатива

            фатальную ошибку исполнения FSM — требует ручного вмешательства

        Альтернативная выдача (QR/экран) позволяет завершить заказ штатно.

        Повторная печать возможна:

            вручную администратором

            автоматически при восстановлении печатающего устройства

        SummaryReceipt сохраняет коды для возможной повторной печати.

    ИСПОЛЬЗУЕМЫЕ СУЩНОСТИ:

        OrderFSMRuntime — FSMState, PickupCode, PinCode, PrintingAttemptResult...

        SummaryReceipt — содержит коды, реквизиты

        OrderLifecycleLog — логирует события PRINTING_FAILED_OR_TIMEOUT, ...ACCEPTED_BY_USER или ...DECLINED_BY_USER

        Device (DeviceType = 'FISCAL_PRINTER' или 'KKT+PRINTER')
        
USER STORY (US011.1)
    ЯВНАЯ ОТМЕНА ЗАКАЗА ПОЛЬЗОВАТЕЛЕМ

    USER STORY (US011.1) DESCRIPTION:
        Как покупатель,
        я хочу иметь возможность отменить заказ вручную до оплаты,
        чтобы отказаться от покупки по собственному решению.

    НАЧАЛЬНОЕ СОСТОЯНИЕ:

        FSM активен: OrderFSMRuntime.FSMState = AWAITING_PAYMENTFSMStatesAndTransitions.

        Order и связанные OrderItem уже созданы.

        Оплата не производилась: в Payment отсутствуют записи с OrderID.

        В ItemLiveAvailable для каждой позиции:

        ReservedQuantity уже увеличен при создании заказа.

    ВЫХОДНОЕ СОСТОЯНИЕ:

        Пользователь нажимает кнопку «Отменить заказ».

        FSM получает событие USER_CANCELLED и переходит в финальное состояние CANCELLED_BY_USERFSMStatesAndTransitions.

        В таблицах фиксируется:

            OrderFSMRuntime.FSMState = CANCELLED_BY_USER

            В OrderLifecycleLog:

                FromState = AWAITING_PAYMENT

                ToState = CANCELLED_BY_USER

                TriggerEvent = USER_CANCELLED

                ActorType = Customer

        В таблице ItemLiveAvailable:

            ReservedQuantity уменьшается на количество, ранее зарезервированное по OrderItem.

            StockLiveQuantity не меняется.

        Пользователь перенаправляется на стартовый экран (меню).
Техническое примечание:
        FSM допускает ручную отмену только в состоянии AWAITING_PAYMENT, до начала фискализации или печати.

        Восстановление ReservedQuantity должно быть атомарным и согласованным с удалением/пометкой Order как отменённого.

        Запись в Order может остаться в статусе PENDING или быть обновлена до CANCELLED — в зависимости от стратегии хранения истории.

    ИСПОЛЬЗУЕМЫЕ СУЩНОСТИ:

        Order

        OrderItem

        OrderFSMRuntime

        OrderLifecycleLog

        ItemLiveAvailable
        
USER STORY (US011.2)
    ВОЗВРАТ В КОРЗИНУ ИЗ ЭКРАНА ОПЛАТЫ

    USER STORY (US011.2) DESCRIPTION:
        Как покупатель,
        я хочу вернуться из экрана оплаты обратно в корзину,
        чтобы изменить заказ до проведения оплаты.

    НАЧАЛЬНОЕ СОСТОЯНИЕ:

        FSM активен: OrderFSMRuntime.FSMState = AWAITING_PAYMENTFSMStatesAndTransitions.

        Пользователь находится на экране “Ожидание оплаты”.

        Order и OrderItem уже созданы.

        Оплата ещё не начата (в Payment нет записей с Status = 'PAID').

    ВЫХОДНОЕ СОСТОЯНИЕ:

        Пользователь нажимает кнопку «Назад в корзину».

        FSM остаётся в том же состоянии AWAITING_PAYMENT, ничего не предпринимает:

            FSM не получает событие,

            статус FSM не меняется,

            FSM просто ждёт действия или таймаута.

        Интерфейс переключается на экран редактирования корзины:

            Пользователь может изменить количество, удалить позиции и т.п.

            Все изменения вносятся во фронтовое состояние, но без модификации записей в БД (OrderItem остаётся неизменным до повторного подтверждения оплаты или отмены).

        FSM переходит в таймер ожидания:

            еесли пользователь не подтвердит заказ повторно или не вернётся к оплате, будет применён INACTIVITY_TIMEOUT (см. US011.3)FSMStatesAndTransitions.

Техническое примечание:
        FSM в AWAITING_PAYMENT допускает возврат в корзину без смены состояния.

        Интерфейс должен обеспечить контроль времени неактивности, чтобы при превышении (30 сек) инициировать отмену FSM (CANCELLED_BY_TIMEOUT).

        Данные в Order и OrderItem можно использовать повторно при возврате к оплате или пересоздать — зависит от архитектуры.

        Редактирование корзины может отображать предупреждение о потенциальном изменении позиций или цен.

Используемые сущности:
        Order — текущий заказ

        OrderItem — список позиций (может быть устаревшим при повторном подтверждении)

        OrderFSMRuntime — остаётся в AWAITING_PAYMENT, FSM не активен
        
USER STORY (US011.3)
    ПАССИВНАЯ ОТМЕНА ЗАКАЗА ПО ТАЙМАУТУ

    USER STORY (US011.3) DESCRIPTION:
        Как система,
        я хочу автоматически завершить заказ, если пользователь не проявляет активности,
        чтобы освободить киоск и вернуть товар в доступный запас.

    НАЧАЛЬНОЕ СОСТОЯНИЕ:

        FSM активен:

            OrderFSMRuntime.FSMState = AWAITING_PAYMENT

            либо пользователь вернулся на экран корзины (но FSM не был отменён вручную).

        Последняя активность пользователя была более 30 секунд назад.
        Order и OrderItem созданы.

        В ItemLiveAvailable увеличен ReservedQuantity.

    ВЫХОДНОЕ СОСТОЯНИЕ:

        Система инициирует событие FSM INACTIVITY_TIMEOUT 

        `FSM переходит в терминальное состояние CANCELLED_BY_TIMEOUT.

        В таблицах фиксируются:

            OrderFSMRuntime.FSMState = CANCELLED_BY_TIMEOUT

            OrderLifecycleLog:

                FromState = AWAITING_PAYMENT

                ToState = CANCELLED_BY_TIMEOUT

                TriggerEvent = INACTIVITY_TIMEOUT

                ActorType = System

        В ItemLiveAvailable:

            ReservedQuantity уменьшается (резерв снимается).

            StockLiveQuantity не изменяется.

        Интерфейс киоска:

            если пользователь ещё на экране — отображается экран "Заказ отменён по неактивности".

            если нет — система автоматически возвращает интерфейс в начальное меню.`

Техническое примечание:
        Таймер неактивности (30 секунд) должен запускаться:

            после перехода в AWAITING_PAYMENT

            или после возврата на экран редактирования корзины

        FSM реализует переход AWAITING_PAYMENT → CANCELLED_BY_TIMEOUT с триггером INACTIVITY_TIMEOUT, с таймаутом 30 секундFSMStatesAndTransitions.

        Поведение не зависит от типа ошибки или действий пользователя — если активности нет, заказ автоматически отменяется.

Используемые сущности:
        Order

        OrderItem

        OrderFSMRuntime

        OrderLifecycleLog

        ItemLiveAvailable — восстановление запасов
        
USER STORY (US012)
    ПЕРЕДАЧА ЗАКАЗА НА ИСПОЛНЕНИЕ ВО ВНЕШНЮЮ СИСТЕМУ (КУХНЮ)

    USER STORY (US012) DESCRIPTION:
        Как система,
        я хочу после успешной оплаты, фискализации и печати,
        передать заказ во внешнюю систему исполнения (например, на кухню),
        чтобы его начали готовить.

    НАЧАЛЬНОЕ СОСТОЯНИЕ:

        FSM прошёл этапы:

            PAYMENT_SUCCEEDED

            FISCALIZATION_SUCCEEDED

            PRINT_SUCCEEDED

        FSM находится в состоянии AWAITING_EXECUTION_CONFIRMATION (OrderFSMRuntime.FSMState)FSMStatesAndTransitions.

        PickupCode и PinCode уже сгенерированы и сохранены в:

            OrderFSMRuntime

            SummaryReceipt

        Пользователь получил коды (на чеке или экране).

    ВЫХОДНОЕ СОСТОЯНИЕ:

        FSM инициирует передачу заказа на исполнение:

            Отправка может происходить:

                через HTTP webhook,

                в очередь (Kafka, Redis и т.п.),

                через API сторонней системы.

            Формируется JSON-структура или аналогичный контракт, содержащий:

                OrderID

                OrderItem с позициями и количеством

                PickupCode, PinCode

                (опционально) StartedAt как предполагаемое время начала исполнения или SLA (в будущем)

        FSM остаётся в состоянии AWAITING_EXECUTION_CONFIRMATION.

        В OrderLifecycleLog создаётся запись:

            FromState = AWAITING_PRINTING

            ToState = AWAITING_EXECUTION_CONFIRMATION

            TriggerEvent = EXECUTION_REQUEST_INITIATED (внутреннее событие, может быть добавлено в расширении FSM)

            ActorType = System

        Внешняя система получает заказ и начинает исполнение (реакция описана в US013).

        Повторные попытки или отложенная отправка (если кухня временно недоступна) могут быть реализованы на уровне очереди/обработчика.

    ТЕХНИЧЕСКОЕ ПРИМЕЧАНИЕ:

        Передача происходит независимо от клиентского интерфейса.

        FSM не завершает заказ без получения ответа от системы исполнения.

        Рекомендуется реализовать очередь или механизм повторов, чтобы гарантировать доставку.

        Обратная связь (подтверждение исполнения) требуется для завершения FSM (см. US013 → EXECUTION_CONFIRMED_BY_EXTERNAL).



    ИСПОЛЬЗУЕМЫЕ СУЩНОСТИ:

        Order — идентификатор и агрегированные данные заказа

        OrderItem — содержимое заказа

        OrderFSMRuntime — содержит FSMState, PickupCode, PinCode

        OrderLifecycleLog — событие отправки на исполнение

        Внешняя система исполнения (кухня, бар и т.п.) — не часть модели, но интеграционная точка
        
USER STORY (US013)
    ПОЛУЧЕНИЕ ПОДТВЕРЖДЕНИЯ О ВЫДАЧЕ ЗАКАЗА ОТ ВНЕШНЕЙ СИСТЕМЫ

    USER STORY (US013) DESCRIPTION:
        Как система,
        я хочу получить подтверждение от внешней системы о том, что заказ был выдан покупателю,
        чтобы зафиксировать полный цикл и завершить FSM.

    НАЧАЛЬНОЕ СОСТОЯНИЕ:

       FSM находится в состоянии AWAITING_EXECUTION_CONFIRMATION (OrderFSMRuntime.FSMState)FSMStatesAndTransitions.

        Заказ ранее был передан во внешнюю систему (см. US012).

        Внешняя система обладает OrderID, PickupCode или PinCode.

    ВЫХОДНОЕ СОСТОЯНИЕ:

        Внешняя система отправляет сигнал о завершении исполнения:

            Например, HTTP-запрос POST /order/complete

            Обязательные поля: OrderID или PickupCode, CompletedAt (время выдачи)

        FSM получает событие EXECUTION_CONFIRMED_BY_EXTERNAL и переходит в финальное состояние COMPLETEDFSMStatesAndTransitions.

        В OrderLifecycleLog создаётся запись:

            FromState = AWAITING_EXECUTION_CONFIRMATION

            ToState = COMPLETED

            TriggerEvent = EXECUTION_CONFIRMED_BY_EXTERNAL

            ActorType = Kitchen или ExternalSystem

            Comment = источник, отметка времени

        OrderFSMRuntime.FSMState = COMPLETED, финализируются данные заказа.

        (Опционально) создаётся запись в отдельной сущности OrderFulfillment, содержащая:

            OrderID, PickupCode, CompletedAt, HandledBy, Method и т.п.

    ТЕХНИЧЕСКОЕ ПРИМЕЧАНИЕ:

        Повторные подтверждения:

            либо игнорируются,

            либо логируются отдельно, без повторного изменения FSM.

        Если сигнал не получен в течение 3 часов — FSM автоматически переходит в UNKNOWN_EXECUTION_NO_RESPONSE (см. таймауты FSM)FSMStatesAndTransitions.

        Интерфейс администратора может предусматривать ручное подтверждение исполнения или запуск fallback-аудита (см. Recovery в FSMDescription)FSMDescription.
    
    ИСПОЛЬЗУЕМЫЕ СУЩНОСТИ:

        Order

        OrderFSMRuntime

        OrderLifecycleLog

        (внешняя система исполнения)

        (опционально: OrderFulfillment)